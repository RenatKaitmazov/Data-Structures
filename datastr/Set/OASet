package datastr.set;

/**
 * Created by Renat Kaitmazov on 18/08/15.
 */

/**
 * OA in the name of the class stands for Open Addressing.
 * It uses double hashing method to find an appropriate place for an element to be stored in the array
 */

public final class OASet<T> {
    /**
     * This class is going to be used when deleting an item.
     */
    private static class DeletedItem {}

    private static final int INITIAL_CAPACITY = 31; // If no value is provided in the constructor

    private Object[] storage;
    private int count = 0;

    public OASet() { storage = new Object[INITIAL_CAPACITY]; }

    public OASet(int initialCapacity) {
        /**
         * Let's imagine that a client want a set of size 4. In this case a set of size 5 will be created instead
         * since it is the nearest prime number to 4. The calculateStep() method may return 5. If this is the case, now suppose
         * that 0th index is occupied. Now let's have a look at the snippet of code from insert() routine. It looks like this:
         * index   += step;
         * index   %= size;
         * 0 is occupied, so the next index is 0 + 5 = 5 and 5 % 5 = 0.
         * As you can see this situation can create an infinite loop and to avoid this we should check the size a client want a set to be.
         * It must not be equal to 4;
         */

        if (initialCapacity == 4) initialCapacity = 5;

        int size    = getNearestPrimeNumber(initialCapacity);
        storage     = new Object[size];
    }

    @Override
    public String toString() {
        if (isEmpty())
            return "{}";
        else {
            StringBuilder builder = new StringBuilder("{");

            for (int i = 0; i < storage.length; i++) {
                T element =(T) storage[i];

                if (element != null && !(element instanceof DeletedItem))
                    builder.append(element.toString()).append(", ");
            }

            int start   = builder.length() - 2;
            int end     = builder.length();
            builder.replace(start, end, "}");

            return builder.toString();
        }
    }

    public boolean isEmpty() { return count == 0; }
    public int size() { return count; }
    public boolean contains(T element) { return find(element) != null; }


    private int abs(int value) {
        return value < 0 ? -value : value;
    }

    private int calculateStep(T forElement) {
        return 5 - (abs(forElement.hashCode()) % 5);
    }

    private boolean isPrimeNumber(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) return false;
        }

        return true;
    }

    /**
     * Since we are going to use double hashing method here, it is vital that our array's size be equal to a prime number
     * Otherwise we can get an infinite loop while inserting an item if several items hash to the same index.
     * This is not the case when array's size equals to a prime number.
     */
    private int getNearestPrimeNumber(int number) {
        int prime = number + 1;

        while (!isPrimeNumber(prime))
            ++prime;
        return prime;
    }

    /**
     * When the array is full, we have to create a new one which is twice as big and move all the elements from the old array
     * to the newly created. Just copying won't do since in the insert() method we calculate an index based on the array's size.
     * After creating a new array its size is larger so we need to recalculate indices for each element.
     */

    private void checkFullness() {
        // Load factor is 0.75

        if (count >= storage.length * 0.75) {
            int newSize = getNearestPrimeNumber(storage.length * 2);
            Object[] newArray = new Object[newSize];

            for (int i = 0; i < storage.length; i++) {
                T element = (T) storage[i];
                if (element != null && !(element instanceof DeletedItem)) {
                    int index = abs(element.hashCode()) % newSize;
                    int step = calculateStep(element);

                    while (newArray[index] != null) {
                        index += step;
                        index %= newSize; // Go to the beginning of the array
                    }

                    newArray[index] = element;
                }
            }

            storage = newArray;
        }
    }

    public void insert(T element) {
        checkFullness();

        int size    = storage.length;
        int index   = abs(element.hashCode()) % size;
        int step    = calculateStep(element);
        T item      = (T) storage[index];


        while (item != null && !(item instanceof DeletedItem)) {
            if (item.equals(element))
                return;

            index += step;
            index %= size;

            item = (T) storage[index];
        }

        storage[index] = element;
        ++count;
    }

    public T delete(T element) {
        if (isEmpty()) return null;

        int size    = storage.length;
        int index   = abs(element.hashCode()) % size;
        int step    = calculateStep(element);

        while (storage[index] != null) {
            if (element.equals(storage[index])) {
                T temp = (T) storage[index];
                storage[index] = new DeletedItem();
                --count;
                return temp;
            }

            index += step;
            index %= size;
        }

        return null;
    }

    public T find(T element) {
        if (isEmpty()) return null;

        int size    = storage.length;
        int index   = abs(element.hashCode()) % size;
        int step    = calculateStep(element);

        while (storage[index] != null) {
            if (storage[index].equals(element))
                return (T)storage[index];

            index += step;
            index %= size;
        }

        return null;
    }
}

package datastructures.linkedlist;

/**
 * Created by RenatKaitmazov on 08/05/15.
 */

public class PriorityQueue<T extends Comparable> {
    private Link<T> head = null;
    private Link<T> tail = null;
    private int count = 0;

    private void connect(Link<T> current, Link<T> newLink) {
        newLink.setNext(current);
        newLink.setPrevious(current.getPrevious());
        current.getPrevious().setNext(newLink);
        current.setPrevious(newLink);
    }

    public boolean isEmpty() { return head == null; }

    public int size() { return count; }

    public void display() {
        if (!isEmpty()) {
            Link<T> current = head;

            while (current != null) {
                System.out.format("%s ", current);
                current = current.getNext();
            }
            System.out.println();
        } else
            System.out.println("The list is empty");
    }

    public T peek() {
        if (isEmpty()) return null;

        return tail.getData();
    }

    public void enqueue(T element) {
        Link<T> newLink = new Link<>(element);

        // if the list is empty, then we just assign new element to the head, and the tail
        if (isEmpty()) {
            head = newLink;
            tail = newLink;
        } else {
            // if not, we will go through the list until we find an appropriate place to insert the new link
            Link<T> current = head;

            while (current.getNext() != null && element.compareTo(current.getData()) > 0)
                current = current.getNext();

            // if this place happened to be the head
            if (current == head) {
                // we need to check whether the element is equal or greater than the head
                // if so, we insert it after the head
                if (element.compareTo(head.getData()) >= 0) {
                    head.setNext(newLink);
                    newLink.setPrevious(head);
                    tail = newLink;
                } else {
                    // if not, we insert it before the head
                    head.setPrevious(newLink);
                    newLink.setNext(head);
                    head = newLink;
                }
            } else if (current == tail) {
                // but if this place happened to be the tail
                // then we need to check once again whether the element is equal or greater than the tail
                // if so, we insert it after the tail
                if (element.compareTo(tail.getData()) >= 0) {
                    tail.setNext(newLink);
                    newLink.setPrevious(tail);
                    tail = newLink;
                } else
                    // if not, we insert it before
                    connect(current, newLink);
            } else
                // if this place is an arbitrary one, we just insert the new link before the "current" link
                connect(current, newLink);
        }
        count++;
    }

    public T dequeue() {
        if (isEmpty()) return null;

        Link<T> temp = tail;
        if (head.getNext() == null)
            head = null;
        else
            tail.getPrevious().setNext(null);

        tail = tail.getPrevious();
        count--;
        return temp.getData();
    }
}
